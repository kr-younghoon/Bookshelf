# 1.1 시스템 프로그래밍

> 시스템 프로그래밍과 애플리케이션 프로그래밍은 중요한 몇몇 부분만 다르고 나머지는 비슷하다..!
> 

*대충 을매나 중요한지가 설명 되어있다. 이하 챕터에서 더 잘 기술되어있을꺼라 생각하고 생략한다.*

*이번 챕터는 이 책의 전체적인 그림과 flow를 가볍게 나마 설명해준다. 어떤 것들이 있구나를 머릿속에 넣으면서 읽어 나가면 좋을꺼 같다.*

# 1.1.1 시스템 프로그래밍을 배워야 하는 이유

> “지난 수십년간 애플리케이션 프로그래밍은 시스템 프로그래밍에서 자바스크립트로 대표할 수 있는 웹 소프트웨어나 자바를 예로 들 수 있는 관리되는 코드(managed code)처럼 더 높은 상위 레벨로 이동중이다.”
> 

중요한 점은 애플리케이션 프로그래밍에서는 트렌드가 변화하고 있음에도 유닉스와 리눅스 코드의 대부분은 시스템 레벨에서 작성된다. 이 코드들은 C와 C++ 이며 C라이브러리와 커널에서 제공하는 인터페이스를 사용하고 있다.
이런 전통적인 시스템 프로그래밍의 대표적인 예는 아파치 웹 서버, Emacs(이맥스) 편집기, Vim 편집기, bash 셸, X 윈도우 시스템, cp, init, gcc, gdb, glibc, ls, mv가 있으며 단기간 안에 사라지지 않을 것들이다.

시스템 프로그래밍 범주에는 커널이나 디바스 드라이버 개발이 포함된다. (하지만, 이 책은 커널 개발을 다루지 않는다.) 대신 커널 위에 존재하는 사용자 영역에서의 시스템 프로그래밍에 중점을 두고 있다.

시스템 레벨 인터페이스란 무엇이며 리눅스에서 어떻게 시스템 레벨 애플리케이션을 작성할 수 있을까? 커널과 C  라이브러리는 정확히 무엇을 제공하나? 최적의 코드를 작성하려면 어떻게 해야하고 리눅스에서는 어떤 방법을 제공하나? 다른 유닉스 시스템과 비교했을 때 리눅스에서만 제공하는 시스템 콜은 무엇인가? 이 모든 것은 어떤 방식으로 동작하나? 이 책에서는 이 모든 질문에 대한 답을 다루고 있다…

# 1.1.2 시스템 프로그래밍의 주춧돌

리눅스 시스템 프로그래밍을 떠받치고 있는 주춧돌 세 가지.

- 시스템 콜
- C 라이브러리
- C 컴파일러

각각에 대해서 알아보자.

# 1.1.3 시스템 콜

> 시스템 프로그래밍은 시스템 콜에서 시작해서 시스템 콜로 끝난다.
> 

## 시스템 콜이란?

운영체제에 리소스나 서비스를 요청하려고 사용자 영역(텍스트 편집기나 게임 같은)에서 시작해서 커널 내부로 들어가는 함수 호출이다.

read(), write() 같은 익숙한 함수에서부터 get_narea(), set_tid_address() 같은 생소한 함수까지 그 범위가 다양하다.

## 시스템 콜 호출하기

사용자 영역의 애플리케이션을 커널 영역으로 직접 연결하는 것은 불가능하다.

> Why?
→ 운영체제는 사용자 영역과 커널 영역으로 나누어져있습니다.
부분에 대해서 집에 있는 책 보고 다시 정리하기.
> 

대신, 애플리케이션이 시스템 콜을 실행하려 한다는 `시그널`을 커널로 보낼 수 있다.
이 메커니즘을 통해야만 커널 내부로 진입하고 커널이 허용한 코드를 실행한다. 물론 정확한 메커니즘은 아키텍쳐마다 다르다.

> For example…
→ 만약 i386(intel)에서는 애플리케이션에서 소프트웨어 인터럽트 명령인 int에 0x80이라는 값을 넘기면 이 명령은 평소에는 보호된 커널 영역으로 들어가 소프트웨어 인터럽트 핸들러를 실행한다. 인터럽트 0x80은 바로 시스템 콜 핸들러이다.
> 
> 
> > 인터럽트가 뭐죠?
> →
> > 
> 
> > 애플리케이션이 OS에서 작동되는 방식? 시스템 콜 시의 부분에 대해서 이해하고 계신가요?
> →
> > 

*이런 부분들에게 질문을 던지게 되지만, 결국엔 1장은 그렇게 중요한 부분이 아니다. 넘어가자*

## 구체적 처리 방식에 대한 예시를 계속 설명해보자..

> 애플리케이션은 실행할 시스템 콜과 매개 변수를 레지스터를 통해 전달한다.
> 

시스템 콜은 0부터 시작하는 숫자로 나타내며 시스템 콜을 호출하려면 레지스터에 해당 시스템 콜을 먼저 저장해야한다. 예를 들어 i386 아키텍쳐에서 시스템 콜 5번(`Open()`)을 호출하려면 응용 프로그램은 int 명령을 실행하기 전에 eax 레지스터에 5를 저장해야한다.

매개 변수 전달도 비슷한 방식으로 처리되는데 i386에서는, ebx, ecx, edx, esi, edi 레지스터에 순서대로 다섯 개의 매개 변수를 저장한다. 매개 변수가 다섯 개 이상 필요할 때는 레지스터 하나에 나머지 모든 매개변수를 담은 사용자 영역의 버퍼를 가리키도록 한다. 물론 대부분의 시스템 콜에는 매개 변수가 두어 개만 있다. → *이 부분에서 솔직히 뭐라고 하는지 잘 모르겠다. 처음 듣는 이야기*

아키텍쳐 별로 시스템 콜을 처리하는 방식은 다르나 기본 원리는 같다. → 커널이 시스템 콜을 처리하는 자세한 내용을 알 필요까지는 없으며, 컴파일러와 C 라이브러리에서 자동으로 처리해준다. *= 중요하지 않다? ㅋㅋ*

# 1.1.4 C 라이브러리

> C 라이브러리(libc) 는 유닉스 애플리케이션의 핵심이다.
> 

심지어 다른 언어로 프로그래밍 해도 상위 레벨의 라이브러리에 포함되어 핵심 서비스와 시스템 콜을 처리하기 위해 C 라이브러리가 동작한다.

*(별로 안중요한거 같다. pass)*

# 1.1.5 C 컴파일러, gcc

> gcc는 C 컴파일러의 실행 파일 이름이기도 하다.
> 

*(수업에서도 많이 쓰이게 될 gcc 컴파일러. 또 보니까 반갑다.)*

리눅스를 포함한 유닉스 시스템에서 컴파일러는 시스템 프로그래밍에서 뗄래야 뗄 수 없는 중요한 요소로 C 표준과 시스템 ABI 구현에 관여한다.
