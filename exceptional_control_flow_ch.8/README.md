# 8. 예외적인 제어흐름, exceptional control flow

### (참고) 이 내용은 교재에 있는 내용들을 요약한 내용이 아니라, 정리한 내용들입니다. 
함축적이지 않고 최대한 이해할 수 있게 늘어 놓았습니다.

> + *시작하기 전,* *교재를 사진찍어달라고 하셔서 다운로드 주소를 첨부합니다. 

첨부 파일 :* ( *예외적인 제어흐름.pdf* )
> 
> 
> [iCloud.com](https://www.icloud.com/iclouddrive/0e7h3C-0i2om-10a1d3scridA)
> 

# 8.0 Introduction

## 🔱 예외적인 제어흐름 (Exceptional Control Flow, ECF)

---

### → 제어이동(Control Transfer), 제어흐름(Control Transfer)

프로세서에 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터(PC)는 다음과 같은 값을 갖습니다. 
→ 인스트럭션 I(k)에 대응되는 주소가 a(k)이다. (사진 참조)

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled.png)

a(k) ~ a(k+1)로의 전환은 `제어이동(Control Transfer)`이라고 부릅니다. 

그림과 같이 프로그램이 실행되는 동안 명령어가 어떻게 실행되는지도 `제어흐름(Control Transfer)` 또는 `프로세서의 제어흐름`이라고 부릅니다. 

---

### → 제어흐름(Control Transfer)의 양상은 크게 세 종류 입니다.

1. **점진적인 제어흐름** : 첫번째 유형의 제어흐름은 **가장 간단하고 일반적 형태**이다. 각 명령어(I_k와 I_k+1)가 메모리에 연속적으로 저장되어 있어 순차적으로 실행됩니다. 이는 프로그램이 기본적인 실행순서에 따라 진행되는 경우로, 대부분의 시간을 차지하는 `제어흐름`입니다.
2. **갑작스런 변화를 가지는 제어흐름** : 두번째 유형의 제어흐름은 **일반적인 점진적인 흐름에 갑작스러운 변화가 발생하는 경우**입니다. 예를 들어, jump, call, return과 같은 프로그램 명령어를 사용하여 현재 실행 위치(I_k)와 인접하지 않은 다른 명령어(I_k+1)로 제어흐름을 전환합니다. (인접해 있지 않은 case인것!) 이러한 명령어들은 프로그램 변수등에 의한 내부 프로그램 상태의 변화에 반응하여 프로그램이 적절하게 동작하도록 하는데 사용됩니다.
3. 예외적인 제어흐름 : 세번째 유형의 제어흐름은 **예외 상황 또는 시스템 상태의 변화에 반응하여 제어흐름이 갑자기 변하는 경우**를 가리킵니다. 이러한 제어흐름을 우리는 `예외적인 제어흐름, exceptional control flow(ECF)` 라고 부른다. 예외적인 제어 흐름은 컴퓨터 시스템의 모든 수준(하드웨어, 운영체제, 응용 프로그램)에서 발생한다.
    
    > **모든 수준에서 ECF는 발생한다! → 모든 수준의 ECF | CS.APP - p.694**
    
    **→ 하드웨어 (Hardware) :** 
    *하드웨어 수준에서는 하드웨어에 의해서 검출되는 이벤트들은 `예외 핸들러(Exception handler)`로 갑작스런 제어이동을 발생시킨다.*
    **→ 운영체제 (OS) :**
    *운영체제 커널 수준의 `문맥전환(context switch)`를 통해서 사용자 프로세스에서 다른 프로세스로 제어가 이동한다.*
    **→ 응용 프로그램(Application) :**
    *1. 프로세스는 시그널을 수신하는 곳에 있는 시그널 핸들러로 제어를 급격히 이동하는 다른 프로세스로 시그널을 보낼 수 있다.
    2. 개별 프로그램은 일반적인 스택 운영을 회피하고 다른 함수 내 임의의 위치로 비지역성 점프를 하는 방법으로 에러에 대응할 수 있다.*
    > 

---

### →  프로그래머로서 ECF를 이해하는 여러가지 중요한 이유가 있다 : (CS.APP - p.694-5)

- **ECF를 이해하면 중요한 시스템 개념을 이해하는 데 도움이 된다.**
    - ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.
    - 이런 중요한 아이디어들을 본격적으로 이해하려면 ECF를 이해할 필요가 있다
- **ECF를 이해하면 어떻게 응용 프로그램들이 운영체제와 상호작용하는지를 이해하는 데 도움이 된다.**
    - 응용 프로그램은 `트랩, Trap` 또는 `시스템 콜, system call` 이라고 알려진 ECF의 한 가지 형태를 사용해서 운영체제로부터 서비스를 요청한다.
        - 예를 들어, 데이터를 디스크에 쓰거나, 네트워크에서 데이터를 읽거나, 새로운 프로세스를 만들거나, 현재 프로세스를 종료시키는 등의 일은 모두 응용 프로그램이 시스템 콜을 호출해서 이루어진다. 기본 시스템 콜 메커니즘을 이해하면 어떻게 이러한 서비스들이 응용 프로그램에 제공되는지 이해하는데 도움이 된다.
- **ECF를 이해하면 재미있는 새로운 응용 프로그램 작성에 도움이 된다.**
    - 운영체제는 새로운 프로세스를 만들거나, 프로세스가 종료하기를 기다리거나, 다른 프로세서에게 시스템 내의 예외 이벤트를 알리거나, 이러한 이벤트를 감지하고 반응하는 등의 작업을 위한 강력한 ECF 메커니즘을 응용 프로그램들에게 제공한다. 만일 이 ECF 메커니즘들을 이해한다면, 이들을 사용해서 Unix 쉘과 웹 서버 같은 흥미로운 프로그램을 작성할 수 있다.
- **ECF를 이해하면 동시성을 이해하는 데 도움이 된다.**
    - ECF는 컴퓨터 시스템에서 `동시성`을 구현하는 기본 메커니즘이다.
    - 다음은 모두 동시성이 적용된 사례들이다. ECF를 이해하는 것은 동시성을 이해하는 첫 단계이다.
        - 실행시간이 중첩되는 프로세스, 쓰레드, 응용 프로그램들의 실행을 가로채는 `예외 처리 핸들러`와 응용 프로그램의 실행을 가로채는 `시그널 핸들러`.
    
    <aside>
    ❓ **동시성(Concurrency) :** 
    컴퓨터 시스템에서 여러작업이 동시에 실행되는 것을 의미합니다. 동시성은 여러 작업이 동시에 진행되는 것처럼 보이도록 만들어 줍니다. 이는 실제로 여러 작업이 동시에 실행되는 것이 아닌, 작업들이 빠르게 번갈아 가며 실행되는 것.
    
    </aside>
    
- **ECF를 이해하면 소프트웨어적인 예외상황이 어떻게 동작하는지 이해하는 데 도움이 될 것이다.**
    - C++, 자바는 try, catch, throw 문장을 통해, 소프트웨어 예외 메커니즘을 제공한다. 소프트웨어 예외는 프로그램이 에러 발생 시에 `비지역성(nonlocal) 점프` (즉, 일반적 call/return 스택 방식에 위배되는 점프)를 하도록 해준다.
    - 비지역성 점프는 응용 프로그램 수준의 ECF이며, C에서는 setjmp, longjmp함수로 제공된다.
    - 이들 하위 함수들을 이해하면 상위 소프트웨어 예외가 어떻게 구현 되는지 이해하는데 도움이 된다.
        - 이러한 Low-level의 함수(setjmp, longjmp)를 이해하면 소프트웨어 수준의 High-level 예외를 이해할 수 있게 된다.

---

### → 마무리

> CSAPP은 1-7장에서 시스템에 대한 여러분의 학습은 응용 프로그램이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다.
> 
> 
> 이번 장은 응용 프로그램이 운영체제와 어떻게 상호작용하는지 배우기 시작하게 되는 측면에서 전환점이라고 볼 수 있다.
> 

운영체제, 하드웨어, 응용프로그램들의 상호작용들은 모두 ECF 중심으로 돌아간다. 앞으로 시작되는 8장에서는 모든 수준에 존재하는 ECF의 다양한 형태를 설명합니다.

> **이번 장에서 설명하게 될 내용**
> 
1. *하드웨어와 운영체제의 교차점에 놓인 예외상황(8.1)*
2. *응용 프로그램에게 운영체제 내부로 엔트리 포인트를 제공하는 예외적인 System Call(8.3)*
3. *응용 프로그램과 운영체제의 교차점에 위치한 프로세스와 시그널(8.4~8.5)*
    1. *비지역성 점프에 대해서 설명하는데, ECF의 응용 프로그램 수준의 형태(8.6)*

# 8.1 예외 상황(Exceptional situation)

<aside>
👶🏻 예외상황은 부분적으로 하드웨어와 운영체제에 의해서 구현된 예외적인 제어 흐름의 한가지 형태이다.

</aside>

![예외 핸들러의 처리과정 : 1. I_curr으로 return / 2. I_next으로 return / 3. abort 루틴(프로그램 종료)](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%201.png)

예외 핸들러의 처리과정 : 1. I_curr으로 return / 2. I_next으로 return / 3. abort 루틴(프로그램 종료)

`예외 상황`은 어떤 프로세스 상태의 변화에 대한 대응으로, 제어흐름의 갑작스런 변화입니다. 위 그림은 기본 아이디어를 보여줍니다.

그림에서 프로세서는 어떤 명령어 I_curr을 실행하고 있을때 프로세서 상태에 중요한 변화가 일어나고 있다. 이 상태는 프로세서 내 다양한 비트들과 신호들로 인코드된다. 상태 변화는 이벤트로 알려져 있다. 이 이벤트는 현재 인스트럭션의 실행에 직접적으로 관련될 수 있습니다. 반면, 이벤트는 현재 인스트럭션의 실행과 관련이 없을  수 있다.

어느 경우이든지 프로세서가 이벤트가 발생했다는 것을 감지하면, `예외 테이블`이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 `간접 프로시저 콜`을 하게 된다.

<aside>
❓ - **간접 프로시저 콜 :** 함수 호출 시 함수의 주소를 포인터나 참조로 전달하여 실행 흐름을 다른 함수로 전환하는 메커니즘
- **인스트럭션 :** 명령어

</aside>

예외처리 핸들러가 처리를 끝마치면, 예외상황을 발생시킨 이벤트의 종류에 따라서 다음과 같은 세 가지 중의 한 가지 일이 발생한다.

1. 핸들러는 제어를 현재 인스트럭션 I_curr로 돌려준다. 이 인스트럭션은 이벤트가 발생했을 때 실행되고 있던 인스트럭션을 말한다.
2. 핸들러는 제어를 I_next로 돌려주는데, 이 인스트럭션은 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션이다.
3. 핸들러는 중단된 프로그램을 종료한다.

# 8.1.1 예외 처리(Exception handling)

예외상황은 이해하기 어려울 수 있는데, 그것은 이들을 처리하려면 HW와 SW가 긴밀하게 협력해야 하기 때문이다. 어떤 컴포넌트가 어떤 일을 수행하는지에 대해서 혼동하기가 쉽다.

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%202.png)

한 시스템 내에서 가능한 예외 상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다. **이 숫자들의 일부는 프로세서 설계자가 부여한 것이다. 나머지 번호는 운영체제 커널(운영체제의 메모리가 상주하는 부분) 설계자가 할당한다.** 

(전자의 예) divide by zero(0으로 나누기 연산), 페이지 오류(Page Fault), 메모리 접근 위반, breakpoint, 산술연산 오버플로우가 포함된다.

(후자의 예) 시스템 콜, 외부 I/O 디바이스로부터의 `인터럽트(Interrupt)`가 포함된다.

운영체제는 시스템 부팅시 `예외 테이블(Exception Table)`을 메모리에 할당 초기화한다. 여기에는 각 예외에 해당하는 예외 핸들러의 주소들이 저장된다. 위의 사진이 예외 테이블의 예이다.

런타임(시스템이 프로그램을 실행하고 있을 때)에 **프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다**. 프로세서는 그 후에 예외 테이블의 엔트리 k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다. 예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작주소는 `예외 테이블 베이스 레지스터(Exception Table Base Register)`라는 특별한 CPU 레지스터에 저장되어 있다.

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%203.png)

`예외상황`(”예외 핸들러의 호출”)은 `프로시저 콜`(”일반적인 함수 호출”)과 유사하지만 일부 중요한 차이점이 있다.  그러나 이 둘은 다음과 같이 중요한 몇 가지의 차이점을 가지고 있다. 예외 처리를 제대로 이해하기 위해선 이 둘의 차이를 이해하는 것이 매우 중요하다.

- 스택에 푸시하는 복귀 주소가 **현재 명령어(I_curr)의 주소일 수도, 다음 명령어(I_next)의 주소일 수도 있다.**
- **복귀 주소뿐만 아니라 다른 추가적인 프로세서 상태 정보도 스택에 푸시**한다. 이는 예외 핸들러가 리턴할 때 모든 프로세서 상태 정보를 원래대로 되돌려 놓기 위함이다. 실제로, x86-64 CPU는 예외 핸들러 호출 시 컨디션 코드 등의 프로세서 상태 정보를 저장하고 있는 EFLAGS라는 레지스터의 값을 스택에 푸시한다. 이렇게 하면 예외 핸들러가 리턴하고 돌아왔을 때 원래 프로그램은 아무 일이 없었던 것처럼 실행을 재개할 수 있다.
- **커널 모드**로 실행된다. 즉, 일반적인 함수와 달리 예외 핸들러는 시스템 자원들에 대한 접근 권한을 갖는다. 따라서 위에서 언급했던 데이터들도 유저 스택이 아닌 **커널 스택**에 푸시가 된다. (예외 핸들러가 리턴할 때 모든 프로세서 상태 정보를 원래대로 되돌려 놓기 위함이다.)

일단 하드웨어가 예외 발생을 감지하여 예외 핸들러의 호출까지 마치고 나면, 나머지 작업은 소프트웨어(예외 핸들러의 처리)에게 맡긴다. 그리고 **처리를 끝낸 예외 핸들러는 예외 종류에 따라 원래 프로그램의 실행 흐름으로 돌아가거나 abort 루틴으로 리턴하여 해당 프로그램을 종료시킨다.** 만약 돌아가야 하는 상황이라면, "*Return from Interrupt*"라는 특별한 명령어를 실행하여 원래 프로그램의 실행 흐름으로 돌아가도록 한다. 이 명령어는 스택에 푸시되어 있는 복귀 주소와 각종 프로세서 상태 정보를 팝 하여 원래대로 되돌려 놓고, (유저 모드로 돌아가는 경우라면) 현재 프로세서의 상태를 유저 모드로 바꿔주는 역할을 수행한다.

# 8.1.2  예외 종류(Exception classes)

> `Interrupt`와 `Trap(System Call)`은 이름 그대로 부르고 나머지를 묶어서 예외라고 합니다.
예외 상황은 네가지 종류로 구분할 수 있다. `인터럽트`, `트랩`, `오류 fault`, `중단 abort` 밑의 테이블은 그 특징들을 요약한 것이다.
> 

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%204.png)

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%205.png)

## 인터럽트(Interrupt)

---

인터럽트는 프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 `비동기적`으로 발생한다. 하드웨어 인터럽트는 비동기적이며, 즉 특정 인스트럭션을 실행해서 발생한 것이 아니라는 의미에서 그렇다 하드웨어 인터럽트를 위한 예외 핸들러는 종종 인터럽트 핸들러라고 부른다.

![(1) 현재 명령어 실행 중에 인터럽트 핀이 High 상태로 전환
(2) 현재 명령어가 완료된 후에 제어가 핸들러로 전달된다.
(3) 인터럽트 핸들러가 실행된다.
(4) 핸들러가 다음 명령어로 돌아간다.](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%206.png)

(1) 현재 명령어 실행 중에 인터럽트 핀이 High 상태로 전환
(2) 현재 명령어가 완료된 후에 제어가 핸들러로 전달된다.
(3) 인터럽트 핸들러가 실행된다.
(4) 핸들러가 다음 명령어로 돌아간다.

현재의 인스트럭션이 실행을 완료한 후에, 프로세서는 인터럽트 핀이 high로 올라갔다는 것을 발견하고 시스템 버스에서 예외번호를 읽으며, 적절한 인터럽트 핸들러를 호출한다. 핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.(즉, 제어흐름에서 인터럽트가 발생하지 않았다면 현재 인스트럭션 다음에 왔을 인스트럭션). 그 효과는 프로그램이 인터럽트가 마치 발생하지 않았던 것처럼 계속해서 실행되는 것이다.

나머지 예외의 종류들(트랩, 오류, 중단)은 지금의 인스트럭션을 실행한 결과로 동기적으로 일어난다.

<aside>
👊🏻 **→ 동기? 비동기?**
동기 : 순차적으로 실행, 한 작업이 완료되지 않으면 다음 작업이 시작되지 않는다.
비동기 : 병렬적으로 실행, 작업의 완료 여부를 기다리지 않고 실행한다.

</aside>

## 트랩과 시스템 콜(Trap, System Call)

---

![(1) 응용 프로그램이 System call 을 호출. → (2) 프로그램 실행흐름이 핸들러로 전달된다. → (3) Trap 핸들러가 실행 → (4) 핸들러가 시스템 콜을 처리한 후, 해당 시스템 콜을 호출한 명령어 다음의 명령어로 돌아간다.](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%207.png)

(1) 응용 프로그램이 System call 을 호출. → (2) 프로그램 실행흐름이 핸들러로 전달된다. → (3) Trap 핸들러가 실행 → (4) 핸들러가 시스템 콜을 처리한 후, 해당 시스템 콜을 호출한 명령어 다음의 명령어로 돌아간다.

`트랩`은 의도적인 예외상황으로, 어떤 특정 인스트럭션을 실행한 결과로 발생한다. 인터럽트 핸들러와 마찬가지로 트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다. 트랩의 가장 중요한 사용은 시스템 콜이라고 알려진 사용자 프로그램과 커널 사이의 프로시저(*일련의 작업을 수행하기 위한 코드 블럭 or 함수)와 유사한 인터페이스를 제공하는 것이다.

사용자 프로그램은 파일을 읽거나(read), 새로운 프로세스를 만들거나(fork), 새 프로그램을 로드하고(execve), 현재 프로세스를 종료하는 등의 서비스를 종종 커널에게 요청할 필요가 있다. 이러한 커널 서비스의 제한된 접근을 하기 위해서 프로세서는 특별한 “n” 인스트럭션을 제공하며, 사용자 프로그램이 서비스 n을 요청하고자 할 때 사용자 프로그램이 사용할 수 있는 인스트럭션이다.

프로그래머의 관점에서 시스템 콜은 보통의 함수 호출과 동일하다. 그렇지만 실제 구현은 매우 다르다!

시스템 콜은 커널 모드에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.

## 오류 (Fault)

---

![(1) 현재 실행중인 명령어가 오류 또는 예외 상황을 발생시킵니다. → (2) 발생한 예외나 오류나 대응하기 위해서, 해당 상황을 처리할 핸들러로 제어가 전달됩니다. → (3) 예외나 오류 처리를 위해 실행되는 핸들러. → (4) 핸들러는 처리 과정에서 현재 실행중인 명령어를 다시 실행하거나, 처리를 중단하고 프로그램을 중단.](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%208.png)

(1) 현재 실행중인 명령어가 오류 또는 예외 상황을 발생시킵니다. → (2) 발생한 예외나 오류나 대응하기 위해서, 해당 상황을 처리할 핸들러로 제어가 전달됩니다. → (3) 예외나 오류 처리를 위해 실행되는 핸들러. → (4) 핸들러는 처리 과정에서 현재 실행중인 명령어를 다시 실행하거나, 처리를 중단하고 프로그램을 중단.

오류는 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생(동기적)한다.

오류 발생하면 프로세서는 제어를 오류 핸들러로 이동해준다. 만일 핸들러가 에러 조건을 정정할 수 있다면, 제어를 오류를 발생시킨 인스트럭션으로 돌려주어서 거기서부터 재실행한다. 그렇지 않다면, 핸들러는 커널 내부의 abort 루틴으로 리턴해서 오류를 발생시킨 응용 프로그램을 종료한다.

Fault의 대표적인 예시는 바로 **페이지 폴트(Page Fault)**이다. 이는 가상 메모리 파트에서 자세히 다룰 예정이므로 여기선 간단히만 소개하도록 하겠다. 명령어가 메인 메모리에 존재하지 않는 가상 페이지에 접근하려 시도하면 예외가 발생하여 페이지 폴트 핸들러가 호출된다. 핸들러는 디스크에 위치해 있는 요청된 가상 페이지를 메인 메모리에 로드하게 되고, 로드 작업이 완료되면 Faulting 명령어로 복귀한다. 그러면 이제는 접근하고자 하는 가상 페이지가 메인 메모리에 존재하므로 예외가 발생하지 않고, 아무 일도 없었던 것처럼 정상적으로 프로그램 실행이 재개된다.

## 중단 (Abort)

---

![(1) 치명적 하드웨어 오류 발생 → (2) 오류가 발생한 상황을 처리하기 위해, 해당 상황을 처리할 핸들러로 제어가 전달됩니다. → (3) 심각한 하드웨어 오류에 대응하기 위해 실행되는 핸들러 → (4) 핸들러는 심각한 하드웨어 오류를 처리한 후, 중단(abort) 루틴으로 제어를 반환합니다.](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%209.png)

(1) 치명적 하드웨어 오류 발생 → (2) 오류가 발생한 상황을 처리하기 위해, 해당 상황을 처리할 핸들러로 제어가 전달됩니다. → (3) 심각한 하드웨어 오류에 대응하기 위해 실행되는 핸들러 → (4) 핸들러는 심각한 하드웨어 오류를 처리한 후, 중단(abort) 루틴으로 제어를 반환합니다.

특정 명령어의 실행 결과로 초래된 (회복 불가능한) 에러에 의해 발생하는 예외로, 명령어의 실행 결과로 발생하는 예외이므로 동기적 예외(Synchronous Exception)에 해당한다. Abort에 해당하는 예외 핸들러는 Abort 핸들러 라고 부르며, Abort 핸들러는 다른 핸들러들과 달리 원래 프로그램의 실행 흐름으로 리턴하지 않고 무조건 abort 루틴으로 리턴하여 프로그램을 종료시킨다. Parity 에러와 같이 치명적인 하드웨어 에러들에 의해 발생하는 예외가 여기에 해당한다.

> *Parrity 에러?
데이터 전송 또는 저장과정에서 발생할 수 있는 오류 중 하나이다.*
> 

# 8.1.3 리눅스/x86-64 시스템에서의 예외상황

구체적인 설명을 위해 x86-64 시스템에서 정의된 일부 예외들을 살펴봅니다. 모두 256개의 서로 다른 예외 종류가 있습니다. 0-31은 인텔 아키텍쳐에서 정의된 예외들에 대응되며, 이들은 인텔 시스템에서 동일합니다. 32-255는 운영체제에서 정의된 인터럽트와 트랩에 대응된다. 밑의 그림은 일부 예를 보여줍니다*.*

![0-18번까지는 x86-64의 CPU 설계자가, 32-255까지는 운영체제에 할당된 것을 볼 수 있다.](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%2010.png)

0-18번까지는 x86-64의 CPU 설계자가, 32-255까지는 운영체제에 할당된 것을 볼 수 있다.

## 리눅스/x86-64 오류와 중단

> → *교재에서는 예외 0번, 13번, 14번, 18번의 자세한 설명이 나온다. 하지만 설명을 생략하겠다. (직접 보세용)*
> 

## 리눅스/x86-64. 시스템 콜

> 리눅스는 파일을 읽거나 쓸 때, 또는 새로운 프로세스를 만들 때 응용 프로그램이 사용할 수 있는 수백 개의 시스템 콜을 제공한다. 밑의 그림은 좀 더 많이 쓰는 리눅스 시스템 콜 테이블에서의 인덱스 일부를 보여준다. 앞서 말했듯 시스템 콜 테이블은 예외 테이블과 다르다는 것에 주의하도록 하자.
> 

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%2011.png)

C 프로그램은 syscall 함수를 직접 실행하여 시스템 콜을 수행할 수 있다.그러나 보통은 C 표준 라이브러리가 제공하는 Wrapper 함수들을 사용하여 시스템 콜을 수행하게 된다. **Wrapper 함수들은 전달되는 인자들을 적절히 해석하고, 알맞은 시스템 콜 명령어를 실행하도록 하며, 시스템 콜의 수행 상태 정보를 호출부에게 반환 값으로 전달해준다.** 참고로, 이와 같은 시스템 콜 및 그것의 Wrapper 함수들을 통들어서 시스템 수준 함수(System-level Function)라고 부르도록 할 것이니 기억해두길 바란다.

아래의 두 그림은 각각 두 종류의 시스템 콜(Write, _exit)을 수행하는 C 언어 프로그램과 그것의 컴파일 결과를 보여준다. 참고로 syscall 명령어를 사용하려면 먼저 %rax에 해당 시스템 콜 번호를 저장해야 하며, 이후의 인자들은 %rdi, %rsi, %rdx, %r10, %r8, %r9에 차례대로 저장해야 한다. 그리고 해당 시스템 콜의 반환 값은 %rax에 저장이 될 것이다.

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%2012.png)

> [Wrapper 함수?](http://www.ktword.co.kr/test/view/view.php?no=1539)
함수 내에 실행코자하는 구현 소스가 있는 것이 아니고, 
호출 부분만 내부 소스로 구현하고, 
이를 알아 보기 쉽게 C 언어 함수 형태의 이름을 지어 놓고, 
수시로 이를 호출할 수 있게하는함수를 말함

例)시스템 콜 등 / ex | fork() , execvp() , open() , read() , write() 등등
> 

# 8.2 프로세스

> 예외 상황은 컴퓨터 공학 분야에서 가장 심오하고 성공적인 개념 중의 하나인 프로세스 개념을 운영체제 커널이 제공할 수 있게 하는 기본 구성 블록이다.
> 
> 
> 프로그램을 실행할 때에 마치 프로그램 자기 혼자만 시스템에서 돌아가고 있는 것 같은 착각이 들게 된다. 즉, 우리의 프로그램은 프로세서와 메모리를 독점해서 사용하는 것처럼 보인다. 프로세서는 프로그램 내의 인스트럭션들을 차례대로 중단됨 없이 실행하는 것처럼 보인다. 또한 프로그램의 코드와 데이터는 시스템 메모리 상의 유일한 객체인 것 처럼 보인다. 이러한 착각은 `프로세스` 라는 개념에 의해서 이루어진다.
> 

## 프로세스 ?

프로세스(Process)란 실행 중인 프로그램의 한 인스턴스(*클래스의 실체화된 개체)를 의미하며 , 각각의  프로세스는 특정 문맥에서 실행된다. 문맥(Context)이란 프로그램이 올바르게 실행되기 위해 필요한 상태 정보들의 집합이다. 예를 들어 메모리의 스택 및 프로그램 코드/데이터, 범용 레지스터, PC(Program Counter), 환경 변수, 파일 기술자 등이 이에 해당한다.

쉘에서 실행 파일의 이름을 입력하면 쉘은 새로운 프로세스를 하나 생성한 뒤, (실행 파일을) 이 새로운 프로세스의 문맥에서 실행한다. 응용 프로그램은 또한 새로운 프로세스를 만들 수 있으며, 새 프로세스의 문맥 내에서 자신의 코드나 다른 응용 코드를 돌릴 수 있다.

프로세스가 응용 프로그램에 제공하는 주요 추상화에 집중할 것이다 : 

- 우리의 프로그램이 프로세서를 혼자서 사용한다는 착각을 제공하는 독립적 논리 제어 흐름(Independent Logical Control Flow)
- 자신이 메모리를 독차지하고 있는 듯한 착각을 제공하는 하나의 사적인 주소 공간(Private Address Space)

# 8.2.1 논리적인 제어흐름(Logical Control Flow)

프로세스는 시스템에 각각 다른 프로그램들이 동시에 동작하고 있지만, 프로세서를 혼자서 사용한다는 착각을 느끼게 한다. 만약 프로그램의 실행을 단일 스텝으로 실행하기 위해서 디버거를 사용해보면, 프로그램과 동적으로 런타임에 링크된 공유 객체 내의 인스트럭션들에게 일련의 프로그램 카운터 PC 값들이 대응된다는 것을 관찰 할 수 있다. 이러한 PC 값들의 배열을 `논리적 제어 흐름` 또는 간단히 `논리 흐름`이라고 부른다. 예를 들어 세 개의 프로세스 A,B,C가 하나의 시스템에서 실행된다고 할 때,  각각의 논리적 제어 흐름을 그림으로 나타내면 다음과 같다.

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%2013.png)

위 그림을 보면 실제로는 각 프로세스들이 교대로 돌아간다는 것을 볼 수 있다. 각 프로세스는 자신의 흐름의 일부분을 실행하고 나서 다른 프로세스들로 순서를 바꾸어 실행하는 동안 선점된다(일시적으로 정지된다.) → preempted(suspended)

이 프로세서 들 중에서 하나의 문맥에서 실행되는 프로그램은 혼자 프로세서를 독차지 하고 있는 것처럼 보인다. 결과적으로 문맥의 변화 없이 실행이 재개되기 때문이다. 

# 8.2.2 동시성 흐름(Concurrent flow)

`논리흐름`은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 갖는다. 예외 핸들러, 프로세스, 시그널 핸들러, 쓰레드, 자바 프로세스는 모두 논리흐름의 예다.

자신의 실행 시간이 다른 흐름과 겹치는 논리 흐름을 동시성 흐름(Concurrent)이라고 부른다. 그리고 그렇게 실행되는 논리적 흐름들을 동시적으로(Concurrently) 실행된다고 표현한다. 예를 들어, 위 예시에서 프로세스 A와 프로세스 B는 동시적으로 실행되지만 프로세스 B와 C는 동시적으로 실행되지 않는다.

여러 개의 논리적 흐름이 동시적으로 실행되는 현상을 동시성(Concurrency)라고 부르며, 각 프로세스가 돌아가면서 사용하는 현상은 멀티태스킹(Multitasking)이라고 부른다. 한편 각 프로세스가 자신의 논리적 흐름 내에서 실제로 프로세스를 사용하고 있는 각각의 시간을 타임 슬라이스(Time Slice)라고 부르기 때문에, 멀티태스킹은 타임 슬라이싱(Time Slicing)이라 부르기도 한다.

참고로 동시적 흐름의 개념은 CPU의 코어 개수와 무관하다. 코어가 한 개인 CPU에서도 두 개의 논리적 흐름이 겹치기만 하면 동시적 흐름이 나타날 수 있는 것이다. 만약 코어가 여러 개인 CPU에서 서로 다른 코어의 논리적 흐름이 겹친다면, 이는 병렬적 흐름(Parallel Flow) 이라고 부른다. 병렬적 흐름은 동시적 흐름의 진부분 집합이며, “실제로 동시에 실행” 되는 흐름이라고 볼 수 있다.

# 8.2.3 사적 주소공간(Private Address Space)

주소를 n비트로 표현하는 컴퓨터에서 주소 공간(Address Space)이란 2^n개의 주소로 이뤄진 집합(0, 1, 2, . . . , 2^n-1)을 의미한다. **프로세스는 각 프로그램에게 사적 주소 공간(Private Address Space)을 제공함으로써 그 프로그램이 메모리를 독차지하고 있는 듯한 착각을 만들어 낸다.** 사적(Private)이라고 표현하는 이유는 해당 공간의 특정 주소에 해당하는 메모리 바이트를 다른 프로세서가 쓰거나 읽을 수 없기 때문이다. 각각의 사적 주소 공간은 내용물이 서로 다르지만, 사적 주소 공간의 구조는 모두 다 동일하다. 예를 들어, x86-64 리눅스 시스템에서는 각 프로세스가 아래와 같은 구조의 사적 주소 공간을 가진다. (참고로 메모리는 하나인데 어떻게 각 프로세스가 아래와 같은 구조의 주소 공간을 똑같이 가질 수 있는지 의문이 들 수 있다. 이와 관련해서는 이후 포스팅에서 다룰 가상 메모리(Virtual Memory) 파트를 참고하길 바란다.)
 

![Untitled](8%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20flow%20b37788051884435084a2f68a996ba0ff/Untitled%2014.png)

# 8.2.4 사용자 및 커널 모드(User and Kernel Mode)

CPU 특정 컨트롤 레지스터의 **모드 비트(Mode Bit)는 현재 프로세스의 특권(Privilege) 유무를 나타낸다.** 모드 비트가 세팅되어 있으면 커널 모드(Kernel Mode) 또는 슈퍼바이저 모드(Supervisor Mode)이며, 모드 비트가 세팅되어 있지 않으면 유저 모드(User Mode)이다. 특권 유무를 나타내는 프로세스의 모드는 실행 가능한 명령어의 범위와 접근 가능한 메모리의 범위를 결정한다.

**커널 모드의 프로세스는 특권(Privilege)을 가지기 때문에 어떤 명령어든지 실행할 수 있고, 시스템 내 모든 메모리 주소 공간에 접근할 수 있다.** 반면에 유저 모드의 프로세스는 특권이 없기 때문에 몇 가지 제약을 받는다. 먼저, **유저 모드의 프로세스는 특권이 필요한 몇몇 명령어들을 실행할 수 없다.** 예를 들어, 유저 모드의 프로세스가 프로세서를 Halt 시키거나, 모드 비트를 수정하거나, 입출력 연산을 수행하는 명령어를 실행하려고 하면 Fatal Protection Fault 예외가 발생할 것이다. 또한, **유저 모드의 프로세스는 주소 공간 중 커널 영역의 데이터와 코드에 직접 접근할 수 없다.** 대신에 시스템 콜 인터페이스를 통해 간접적으로만 커널 영역의 데이터와 코드에 접근할 수 있다.

최초에 응용 프로그램이 실행될 때 생성되는 프로세스는 유저 모드이다. **프로세스가 유저 모드에서 커널 모드로 바뀌는 경우는 인터럽트, 폴트, 시스템 콜 등의 예외가 발생할 때이다.** 예외가 발생하면 제어가 예외 핸들러로 넘어가면서 프로세서에 의해 모드가 커널 모드로 바뀌고, 응용 프로그램의 코드로 돌아갈 때 프로세서에 의해 모드가 다시 유저 모드로 바뀌게 된다.

# 8.2.5 문맥 전환(Context Switch)

문맥 전환(Context Switch)은 멀티태스킹(Multitasking)을 구현하는 기본적인 메커니즘으로, 운영체제 커널에 의해 수행이 되는 높은 수준의 ECF에 해당한다. 문맥 전환 메커니즘은 앞에서 다루었던 낮은 수준의 ECF에 해당하는 예외 메커니즘을 기반으로 구현이 된다. 먼저 문맥이라는 것이 정확히 무엇인지 알아보고, 문맥 전환은 언제 어떻게 발생하는지 알아보도록 하자.

**3-6-1. 문맥 (Context)**

커널은 각 프로세스의 문맥을 관리한다. **문맥(Context)은 커널이 잠들어 있는 프로세스를 다시 실행하는 데 필요한 모든 상태 정보**를 의미한다. 대표적으로 범용 레지스터, 프로그램 카운터, 상태 레지스터, 유저 스택, 커널 스택, 기타 커널 자료 구조(EX. 페이지 테이블, 프로세스 테이블, 파일 테이블) 등의 정보들이 이에 해당한다.

**3-6-2. 문맥 전환 (Context Switch)**

프로세스 A를 실행하고 있을 때 또 다른 프로세스로 제어가 넘어가야 하는 특정 이벤트가 발생하면 커널의 **스케쥴러(Scheduler)** 루틴이 호출된다. 스케쥴러는 프로세스 A를 잠들게 하고, 현재 잠들어 있는 다른 프로세스들 중에서 새로 실행할 프로세스 B를 선택한다. 이러한 과정을 **스케쥴링(Scheduling)**이라고 하며, 프로세스 B가 스케쥴러에 의해 스케쥴 되었다(Scheduled)고 표현한다. 이렇게 새로 실행할 프로세스 B를 선택되고 나면, 스케쥴러는 프로세스 A에서 프로세스 B로의 문맥 전환을 수행하게 된다. **문맥 전환(Context Switch)은 현재 프로세스의 문맥을 저장하고, 새로 실행할 프로세스의 문맥을 복원하며, 제어를 해당 프로세스로 넘겨주게 된다.**

**3-6-3. 문맥 전환이 발생하는 시점**

그렇다면 문맥 전환은 언제 발생할까? 먼저, **커널이 시스템 콜을 수행하고 있을 때 발생**할 수 있다. 만약 **어떤 시스템 콜이 특정 이벤트의 발생을 기다린다면, 이는 스케쥴러를 호출하여 현재 프로세스를 잠들게 하고 다른 프로세스에게 제어를 넘겨주는 문맥 전환을 수행한다.** 예를 들어, read 시스템 콜은 디스크에게 요청한 데이터가 도착할 때까지 다른 프로세스로의 문맥 전환을 수행하고, sleep 시스템 콜은 정해진 시간 동안 현재 프로세스를 잠들게 하고 다른 프로세스로의 문맥 전환을 수행한다. 또한, 문맥 전환은 **인터럽트의 결과로 발생**할 수도 있다. 예를 들어, 대부분의 시스템들은 주기적으로(1ms ~ 10ms 간격) 타이머 인터럽트를 발생시키는 메커니즘을 가지고 있다. 타이머 인터럽트가 발생하면 커널은 현재 프로세스가 너무 오래 실행되었다고 판단하고 새로운 프로세스로의 문맥 전환을 수행한다. 또한, 디스크가 요청된 데이터를 메모리에 로드하는 작업을 완료하고 프로세서에게 인터럽트를 발생시키면 커널은 현재 프로세스를 잠들게 하고 원래 프로세스로 제어를 넘겨주는 문맥 전환을 수행한다.

다음 그림은 프로세스 A와 프로세스 B 사이의 문맥 전환 예시를 보여준다. 유저 모드로 실행되고 있던 프로세스 A는 read 시스템 콜을 통해 커널의 트랩 핸들러를 호출한다. 그러면 해당 트랩 핸들러는 디스크 컨트롤러에게 DMA Transfer를 요청하고, 디스크 컨트롤러의 메모리 로드 작업이 끝나면 프로세서에게 인터럽트를 걸 수 있도록 준비시킨다. 그런데 디스크 읽기 작업은 상당히 많은 시간을 소요하기 때문에, 트랩 핸들러는 가만히 기다리지 않고 스케쥴러를 호출하여 프로세스 B로의 문맥 전환을 수행한다. 그렇게 프로세스 B가 실행되다가 디스크 읽기 작업이 완료되어 인터럽트가 발생하면 다시 스케쥴러를 호출하여 프로세스 A로의 문맥 전환을 수행한다.

![https://blog.kakaocdn.net/dn/basvPF/btqCX9SOA0P/4KKEdxIsfQHGE3alnGKzw1/img.png](https://blog.kakaocdn.net/dn/basvPF/btqCX9SOA0P/4KKEdxIsfQHGE3alnGKzw1/img.png)

# 8.3 시스템 콜의 에러 처리→ 진짜 뭔소린지 모르겠음.

Unix의 시스템 수준함수가 에러를 만날때 이들은 대개 -1을 리턴하고, 전역 정수 변수인 errno를 세팅해서 무엇이 잘못되었는지를 나타낸다. 프로그래머들은 반드시 에러를 체크해야 하지만 불행하게도 많은 경우에 에러 체크를 생략하는데, 그것은 이 작업이 코드를 키워서 읽기 더 어렵게 하기 때문이다. 예를 들어, 다음은 리눅스 fork 함수를 호출할 때 어떻게 에러를 체크하는지를 보여준다:

```c
if ((pid = fork()) < 0) {
		fprintf(stderr, "fork error: %s\n", strerror(errno));
		exit(0);
}
```

strerror함수는 errno의 특정 값과 연계된 에러를 설명하는 텍스트 스트링을 리턴한다. 이 코드를 다음과 같이 에러 리포트 함수를 정의해서 약간 단순화할 수 있다:

```c
void unix_error(char *msg) /* Unix-style error */
{
		fprintf(stderr, "%s: %s\n", msg, strerror(errno));
		exit(0);
}
```

이 함수가 주어지면, fork로 호출하는 것이 네 줄에서 두 줄로 줄어든다 :

```c
		if((pid == fork()) < 0)
				unix_error("fork error");
```

이 코드를 [110]에서 Stevens가 개발한 에러 핸들링 래퍼를 사용해서 좀 더 단순화 할 수 있다. 주어진 기초 함수 foo에 대해서, 래퍼 함수 Foo를 동일한 인자를 갖도록 정의하지만 이름의 첫글자는 대문자로 하였다. 래퍼는 기초 함수를 호출하고, 에러를 체크해서 만일 문제가 있다면 종료한다. 예를 들어, 다음은 함수에 대한 에러 핸들링 래퍼다:

```c
pid_t Fork(void) {
		pid_t pid;

		if ((pid = fork()) < 0)
				unix_error("Fork error");
		return pid;
}
```

이 래퍼가 주어질 때, fork로 호출하는 것이 하나의 압축된 라인으로 줄어든다 :

```c
		pid = Fork();
```

이 책에서는 에러 핸들링 래퍼를 사용할 것이다. 이들을 사용하면 에러 체크를 무시해도 된다는 잘못된 인상을 주지 않으면서도 코드 예제가 간략해진다. 다음 절에서 시스탐-수준 함수에 대해 설명할 때, 대문자는 래퍼를 나타내고 소문자는 항상 기본 이름을 나타낸다는 점에서 주목해야 한다.

Unix 에러 핸들링과 이 책에서 사용한 에러 핸들링 래퍼에 관한 설명에 대해서는 부록 A를 참고하기 바란다. 래퍼는 csapp.c 파일에 정의되어 있으며, 이들의 프로토타입은 헤더 파일 csapp.h에 정의되어 있다; 이들은 온라인으로 CS:APP 웹 사이트에서 찾아볼 수 있다.

# 8.4 프로세스의 제어

Unix는 C 프로그램으로부터 프로세스를 제어하기 위한 많은 시스템 콜을 제공한다. 이 절에서는 중요한 함수들을 설명하고, 이들이 어떻게 사용되는지 예제를 제공한다.

# 8.4.1 프로세스 ID 가져오기

각각의 프로세스는 고유의 양수(0이 아닌) 프로세스 ID(PID)를 가집니다.

### getpid 함수

getpid 함수는 호출하는 함수의 PID를 리턴한다. getppid 함수는 자신의 부모의 PID를 리턴한다.(즉, 호출하는 프로세스를 만드는 프로세스를 말한다.)

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);

Returns: the caller or the parent의 PID
```

getpid와 getppid 루틴은 pid_t타입의 정수 값을 리턴하여, 이 타입은 리눅스 시스템에서 types.h에 정수로 정의되어 있다.

# 8.4.2 프로세스의 생성과 종료

프로그래머의 관점에서 프로세스는 다음의 세 가지 상태 중의 하나로 생각할 수 있다:

실행중(Running). 프로세스는 CPU에서 실행하고 있거나 실행을 기다리고 있으며, 궁극적으로 커널에 의해서 스케줄 될 것이다.

정지(Stopped). 프로세스의 실행은 정지한 상태이고 스케줄되지 않는다. 프로세스는 SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 시그널을 받게 되면 그 결과로 정지하고, SIGCONT 시그널을 받을 때까지 정지 상태로 남아 있으며, 이 시그널을 받은 시점에서 다시 실행을 시작하게 된다.(시그널은 일종의 소프트웨어 인터럽트로 8.5절에서 자세히 설명한다.)

종료(Terminated). 프로세스는 영구적으로 정지된다. 프로세스는 다음의 세 가지 이유 중의 하나로 종료된다 : (1) 프로세스를 종료하는 시그널을 받았을 때, (2) 메인 루틴에서 리턴할 때, (3) exit함수를 호출할때.

## exit() 함수

```c
#include <stdlib.h>
void exit(int status);

This function does not return
```

exit 함수는 종료 상태 status로 프로세스를 종료한다.(exit status를 설정하는 다른 방법은 메인 루틴에서 정수 값을 리턴하는 것이다).

## fork() 함수

부모 프로세스는 fork함수를 불러서 자식 프로세스를 생성한다.

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);

Returns: 0 to child, PID of child to parent, -1 on error
```

새롭게 생성된 자식 프로세스는 완벽하게는 아니지만 부모와 거의 동일하다. 자식은 코드, 데이터 세그먼트, 힙, 공유된 라이브러리, 사용자 스택을 포함하는 부모의 사용자 수준 가상 주소 공간과 동일한 (그러나 분리된) 복사본을 갖는다. 자식은 또한 부모가 오픈한 파일 식별자 모두와 동일한 사본을 갖는다. 

이것은 부모가 fork를 호출했을 때 부모가 오픈한 파일 모두를 읽고 쓸 수 있다는 것을 의미한다. 부모와 새롭게 생성된 자식 간의 가장 중요한 차이는 이들이 서로 다른 PID를 가진다는 것이다.

fork함수는 흥미로운데(그리고 종종 헷갈리기도한다), 그것은 이들이 한번 호출되지만 두 번 리턴하기 때문이다:
한번은 호출한 프로세스에서(부모), 다른 한번은 새롭게 생성된 자식 프로세스에서. 부모에서 fork는 자식의 PID를 리턴한다. 자식에서 fork는 0을 리턴한다. 자식의 PID가 항상 0이 아니기 때문에 리턴 값은 프로그램이 부모에서 실행하고 있는지 자식에서 실행하는지를 구분하는 명확한 방법을 제공한다.

```c
> code/ecf/fork.c

int main() {
		pid_t pid;
		int x = 1;

		pid = Fork(); // - 6번째 줄
		if (pid == 0) { /* child */
				printf("child: x=%d\n", ++x); // - 8번째 줄
				exit(0);
		}

		/* Parent */
		printf("parent: x=%d\n", --x); // - 13번째 줄
		exit(0);
}

> fork를 사용해서 새로운 프로세스 만들기.
```

fork를 사용해서 자식 프로세스를 만드는 부모 프로세스의 간단한 예를 보여준다. fork가 6번 줄에서 리턴 할 때는 부모와 자식 모두에서 1을 갖는다. 자식은 8번줄에서 x의 사본을 증가시키고 출력한다. 마찬가지로, 부모는 13번 줄에서 x의 자신의 사본을 감소시키고 출력한다.

이 프로그램을 Unix 시스템에서 돌릴 때 다음과 같은 결과를 얻는다:

```c
linux> ./fork
parent: x = 0
child : x = 2
```

이 간단한 예제에는 다소 미묘한 측면들이 있다.

### 한 번 호출하고 두 번 리턴한다.

fork함수는 부모에 의해서 한 번 호출되지만 리턴은 두 번 한다: 한 번은 부모가, 다른 한 번은 새로 만든 자식이. 이것은 한 개의 자식을 만드는 프로그램들에 대해서는 매우 명확하다. 그러나 여러 개의 fork를 갖는 프로그램은 헷갈릴 수 있으며 주의 깊게 생각할 필요가 있다.

### 동시 실행

부모와 자식은 동시에 돌아가는 별도의 프로세스들이다. 이들의 논리적 제어흐름 내의 인스트럭션들은 커널에 의해서 임의의 순서로 중첩될 수 있다. 우리의 시스템에서 프로그램을 실행할 때, 부모 프로세스는 자신의 printf 문장을 먼저 완료하고, 다음으로 자식이 실행된다. 그렇지만, 다른 시스템에서는 그 반대 상황으로 진행될 수도 있다. 일반적으로, 프로그래머로서 우리는 서로 다른 프로세스 내에서 인스트럭션들 간의 중첩 실행에 관해 절대로 가정 할 수 없다.

### 중복된, 그러나 별도의 주소공간

만일 부모와 자식을 각 프로세스에서 fork함수가 리턴한 직훼 중단할 수 있다면, 각 프로세스의 주소공간이 동일하다는 것을 알 수 있을 것이다. 각 프로세스는 동일한 사용자 스택, 지역변수 값들, 힙, 전역변수 값, 동일한 코드를 가진다. 그래서 우리의 예제 프로그램에서, 지역변수 x는 fork 함수가 6번 줄에서 리턴할 때 부모와 자식 모두에서 1을 가진다. 그렇지만 부모와 자식이 별도의 프로세스이므로 이들은 자신만의 사적 주소 공간을 가진다. 그래서 우리의 예제 프로그램에서, 지역변수 x는 fork 함수가 6번 줄에서 리턴할 때 부모와 자식 모두에서 1을 가진다. 그렇지만 부모와 자식이 별도의 프로세스이므로 이들은 자신만의 사적 주소공간을 가진다. 부모나 자식이 x에 대해 가하는 이후의 수정사항들은 모두 개인적이며 다른 프로세스의 메모리에는 반영되지 않는다. 이것을 통해서 변수 x에 대해서 부모와 자식이 똑같은 printf 문장을 호출할 때 서로 다른 값을 가지게 되는지를 알 수 있다.

### 공유된 파일

예제 프로그램을 실행할 때, 부모와 자식 모두가 자신의 출력을 화면을 통해서 한다는 것을 알 수 있다. 그 이유는 자식이 부모가 오픈한 모든 파일들을 상속받았기 때문이다. 부모가 fork를 호출 할 때, stdout 파일은 열려 있으며, 화면으로 재지정되어 있다. 자식은 이 파일을 상속하였으며, 그래서 자신의 출력도 화면으로 가게 된다.

fork 함수를 처음 배울 때 프로세스 그래프를 그려보면 도움이 된다. 이 그래프는 프로그램 문장들의 부적인 순서를 나타내는 순서그래프의 단순한 종류다. 각 꼭짓점 a는 프로그램 문장 하나의 실행에 대응된다. 방향성 에지 a → b는 문장 a가 문장 b보다 ‘이전에 발생(happens before)’한다는 것을 나타낸다. 에지들은 현재 변수 값과 같은 정보로 표시될 수 있다. printf 문장에 대응하는 꼭짓점들은 printf의 출력으로 표시될 수 있다. 각 그래프는 main을 호출하는 부모 프로세스에 대응 하는 꼭짓점으로 시작한다. 이 꼭짓점은 들어오는 에지는 없으며, 정확히 한 개의 나가는 에지를 갖는다. 각 프로세스에 대한 꼭짓점들의 순서는 exit으로의 호출에 대응하는 꼭짓점으로 끝난다. 이 꼭 짓점은 한 개의 들어오는 에지를 가지며, 나가는 에지는 없다.

예를 들어, 그림 8.16은 그림 8.15의 예제 프로그램에 대한 프로세스 그래프를 보여준다. 처음에 부모는 변수 x를 1로 설정한다. 부모는 fork를 호출하고, 이것은 자신만의 사적 주소 공간에서 부모와 함께 동시적으로 실행하는 자식 프로세스를 한 개 생성한다.